"""
|â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢| 
â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡         |           â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡

                          GNU GENERAL PUBLIC LICENSE
                            Version 3, 29 June 2007
                            
        Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
            Everyone is permitted to ğ—°ğ—¼ğ—½ğ˜† ğ—®ğ—»ğ—± ğ—±ğ—¶ğ˜€ğ˜ğ—¿ğ—¶ğ—¯ğ˜‚ğ˜ğ—² verbatim copies
                of this license document, ğ—¯ğ˜‚ğ˜ ğ—°ğ—µğ—®ğ—»ğ—´ğ—¶ğ—»ğ—´ ğ—¶ğ˜ ğ—¶ğ˜€ ğ—»ğ—¼ğ˜ ğ—®ğ—¹ğ—¹ğ—¼ğ˜„ğ—²ğ—±.
                        â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡,
                        Telegram Music player userbot 
                has been licensed under GNU General Public License
            ğ‚ğ¨ğ©ğ²ğ«ğ¢ğ ğ¡ğ­ (ğ‚) ğŸğŸğŸğŸ ğ—›ğ˜†ğ—½ğ—²ğ—©ğ—¼ğ—¶ğ—±ğ—¦ğ—¼ğ˜‚ğ—¹ | ğ—›ğ˜†ğ—½ğ—²ğ—©ğ—¼ğ—¶ğ—±ğ—Ÿğ—®ğ—¯ | ğ—›ğ˜†ğ—½ğ—²ğ—©ğ—¼ğ—¶ğ—±ğ˜€
â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡         |           â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡
|â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢|        
"""
from É¦ÊÖ„É›Ê‹Ö…É¨É–ÆˆÖ…Ö„ÊÊ€É¨É¢É¦È¶.á´˜á´œÊ€É¢á´‡_á´á´‡á´„Êœá´€É´Éªêœ±á´ import * 
from É¦ÊÖ„É›Ê‹Ö…É¨É–ÆˆÖ…Ö„ÊÊ€É¨É¢É¦È¶.á´á´œêœ±Éªá´„_á´„á´É´á´›á´‡É´á´› import *
from É¦ÊÖ„É›Ê‹Ö…É¨É–ÆˆÖ…Ö„ÊÊ€É¨É¢É¦È¶.xá´‡Ê€á´êœ°ÉªÊŸá´‡á´›êœ± import *
from É¦ÊÖ„É›Ê‹Ö…É¨É–ÆˆÖ…Ö„ÊÊ€É¨É¢É¦È¶.ÊŸÉªÊ™Ê€á´€Ê€Ê import *
from É¦ÊÖ„É›Ê‹Ö…É¨É–ÆˆÖ…Ö„ÊÊ€É¨É¢É¦È¶.Êœá´á´á´‡ import *



@Client.on_message(
filters.group
& ~filters.edited
& Known_admins
& Xero_Singer
& filters.command("sing", prefixes="/"))
async def play_track(client, XS: XeroSpeak):
    group_call = XePlay.group_call
    playlist = XePlay.playlist   
   
    
    "Check Wherether audio duration matches with the specified time mentioned in the code"
    if XS.audio:
        if XS.audio.duration > (MAX_MIN * 60):
            reply = await XS.reply_animation(
                animation=xerolink,
                caption=f"{XEXO}ğŸ§ ğ—”ğ˜‚ğ—±ğ—¶ğ—¼ ğ˜„ğ—µğ—¶ğ—°ğ—µ ğ—±ğ˜‚ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¹ğ—¼ğ—»ğ—´ğ—²ğ—¿ ğ˜ğ—µğ—®ğ—» {str(MAX_MIN)} ğ—ºğ—¶ğ—» ğ˜„ğ—¼ğ—»'ğ˜ ğ—¯ğ—² ğ—®ğ˜‚ğ˜ğ—¼ğ—ºğ—®ğ˜ğ—¶ğ—°ğ—®ğ—¹ğ—¹ğ˜† ğ—®ğ—±ğ—±ğ—²ğ—± ğ˜ğ—¼ ğ—½ğ—¹ğ—®ğ˜†ğ—¹ğ—¶ğ˜€ğ˜",
                reply_markup = MIB
            )
            await xeronoid_sing_purge(
                (reply,),
                PLAY_REMOVER)
            return
        m_audio = XS
    elif XS.reply_to_message and XS.reply_to_message.audio:
        m_audio = XS.reply_to_message
        if m_audio.audio.duration > (MAX_HOUR * 60 * 60):
            reply = await XS.reply_animation(
                animation=xerolink,
                caption=f"{XEXO}ğŸ§ ğ—”ğ˜‚ğ—±ğ—¶ğ—¼ ğ˜„ğ—µğ—¶ğ—°ğ—µ ğ—±ğ˜‚ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¹ğ—¼ğ—»ğ—´ğ—²ğ—¿ ğ˜ğ—µğ—®ğ—» {str(MAX_HOUR)} ğ—µğ—¼ğ˜‚ğ—¿ğ˜€ ğ˜„ğ—¼ğ—»'ğ˜ ğ—¯ğ—² ğ—®ğ—±ğ—±ğ—²ğ—± ğ˜ğ—¼ ğ—½ğ—¹ğ—®ğ˜†ğ—¹ğ—¶ğ˜€ğ˜",
                reply_markup = MIB
            )
            await xeronoid_sing_purge(
                (reply,),
                PLAY_REMOVER)
            return
    else:
        await XePlay.send_playlist()
        await XS.delete()
        return
    
    
        
    
    
    "Check Wherether audio is already added in the playlist or not"
    if playlist and playlist[-1].audio.file_unique_id \
            == m_audio.audio.file_unique_id:
        reply = await XS.reply_animation(
            animation=xerolink,
            caption=f"{XEXO}ğŸ§  ğ—§ğ—µğ—®ğ˜ ğ—ºğ˜‚ğ˜€ğ—¶ğ—° ğ—¶ğ˜€ ğ—®ğ—¹ğ—¿ğ—²ğ—®ğ—±ğ˜† ğ—®ğ—±ğ—±ğ—²ğ—± ğ˜ğ—¼ ğ˜ğ—µğ—² ğ˜…ğ—²ğ—¿ğ—¼ğ—»ğ—¼ğ—¶ğ—± ğ—½ğ—¹ğ—®ğ˜†ğ—¹ğ—¶ğ˜€ğ˜",
            reply_markup = MIB
            )
        await xeronoid_sing_purge(
            (reply,),
            PLAY_REMOVER)
        return
    
    
        
    
    "Download the raw audio file and send to the server and return"
    playlist.append(m_audio)
    if len(playlist) == 1:
        m_status = await client.send_animation(
            animation=xerolink,
            duration=10,
            chat_id=LOGGER_ID,
            caption=f"{XEXO}ğŸ§ ğ— ğ˜‚ğ˜€ğ—¶ğ—° ğ—µğ—®ğ˜€ ğ—¯ğ—²ğ—²ğ—» ğ˜€ğ—²ğ—»ğ˜ ğ˜ğ—¼ ğ˜ğ—µğ—² ğ˜€ğ—²ğ—¿ğ˜ƒğ—²ğ—¿...\nğ™‹ğ™¡ğ™šğ™–ğ™¨ğ™š ğ™¬ğ™–ğ™ğ™©"
        )
        
        
        m_status = await XS.reply_animation(
            animation=xerolink,
            caption=f"{XEXO}ğŸ§ ğ—£ğ—¹ğ—²ğ—®ğ˜€ğ—² ğ˜„ğ—®ğ—¶ğ˜ ğ—³ğ—¼ğ—¿ ğ˜…ğ—²ğ—¿ğ—¼ğ—»ğ—¼ğ—¶ğ—± ğ˜ğ—¼ ğ—¹ğ—¶ğ—»ğ—¸ ğ˜„ğ—¶ğ˜ğ—µ ğ˜‚ğ˜€ğ—²ğ—¿ğ—¯ğ—¼ğ˜'ğ˜€ ğ˜€ğ—²ğ—¿ğ˜ƒğ—²ğ—¿...\nğ™‚ğ™§ğ™šğ™–ğ™©ğ™šğ™§ ğ™–ğ™ªğ™™ğ™ğ™¤ ğ™¨ğ™ğ™¯ğ™š, ğ™¢ğ™¤ğ™§ğ™š ğ™©ğ™ğ™¢ğ™š ğ™©ğ™¤ ğ™–ğ™™ğ™™ ğ™©ğ™¤ ğ™¨ğ™šğ™§ğ™«ğ™šğ™§",
            reply_markup = MIB
        )
        await download_audio(playlist[0])
        
        
        group_call.input_filename = os.path.join(
            client.workdir,
            DEFAULT_DOWNLOAD_DIR,
            f"{playlist[0].audio.file_unique_id}.raw"
        )
        await XePlay.update_start_time()
        await m_status.delete()
        
        
        
        
        "Log the audio being transcoded and played in the group..."
        await client.send_animation(
            animation=xerolink,
            duration=10,
            chat_id=LOGGER_ID,
            caption=f"{XEXO}ğŸ§  ğ—«ğ—²ğ—¿ğ—¼ğ—»ğ—¼ğ—¶ğ—± ğ˜‚ğ˜€ğ—²ğ—¿ğ—¯ğ—¼ğ˜ ğ—µğ—®ğ˜€ ğ˜€ğ˜ğ—®ğ—¿ğ˜ğ—²ğ—± ğ—½ğ—¹ğ—®ğ˜†ğ—¶ğ—»ğ—´:\n\n{playlist[0].audio.title}"
        )
        # Only userbot is going to log this event. So we need not to worry about Xeronoidbot
        
    await XePlay.send_playlist()
    for track in playlist[:2]:
        await download_audio(track)
    if not XS.audio:
        await XS.delete()
        
