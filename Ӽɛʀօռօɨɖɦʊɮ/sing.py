"""â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹ Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡         |           â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹ Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡
|----------------------------------------------------------------------------------------|
                          GNU GENERAL PUBLIC LICENSE
                            Version 3, 29 June 2007
                            
        Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
            Everyone is permitted to ğ—°ğ—¼ğ—½ğ˜† ğ—®ğ—»ğ—± ğ—±ğ—¶ğ˜€ğ˜ğ—¿ğ—¶ğ—¯ğ˜‚ğ˜ğ—² verbatim copies
                of this license document, ğ—¯ğ˜‚ğ˜ ğ—°ğ—µğ—®ğ—»ğ—´ğ—¶ğ—»ğ—´ ğ—¶ğ˜ ğ—¶ğ˜€ ğ—»ğ—¼ğ˜ ğ—®ğ—¹ğ—¹ğ—¼ğ˜„ğ—²ğ—±.

                        â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹ Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡,
                        Telegram Music player userbot 
                has been licensed under GNU General Public License
            ğ‚ğ¨ğ©ğ²ğ«ğ¢ğ ğ¡ğ­ (ğ‚) ğŸğŸğŸğŸ ğ—›ğ˜†ğ—½ğ—²ğ—©ğ—¼ğ—¶ğ—±ğ—¦ğ—¼ğ˜‚ğ—¹ | ğ—›ğ˜†ğ—½ğ—²ğ—©ğ—¼ğ—¶ğ—±ğ—Ÿğ—®ğ—¯ | ğ—›ğ˜†ğ—½ğ—²ğ—©ğ—¼ğ—¶ğ—±ğ˜€
|----------------------------------------------------------------------------------------|       
â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹ Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡         |           â‡œâŠ·Â°â€¢â™ª   ğŸ¦‹ Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ğŸ¦‹   â™ªâ€¢Â°âŠ¶â‡"""


from É–Ö…Ö…Ê_Ê€Ö…Ö…Ê import *
from ÇŸÊŠÈ¶Ö…_Ö„ÊŠÊ€É¢É›Ê€ import *
from ÊŸÉ¨É®Ê€ÇŸÊ€Ê_Ê€Ö…Ö…Ê import *
from Ó¼É›Ê€Ö…Õ¼Ö…É¨É–ÊÊŠÖ†É¨Æˆ import *
from ÆˆÊŠÖ†È¶Ö…Ê_Ê„É¨ÊŸÈ¶É›Ê€Ö† import *


@Client.on_message(
    filters.group
    & ~filters.edited
    & current_vc
    & (filters.regex("^(\\/|!)sing$") | filters.audio)
)
async def play_track(client, m: Message):
    group_call = xep.group_call
    playlist = xep.playlist
    # check audio
    if m.audio:
        if m.audio.duration > (MAX_MIN * 60):
            reply = await m.reply_text(
                f"{emoji.ROBOT} audio which duration longer than "
                f"{str(MAX_MIN)} min won't be automatically "
                "added to playlist"
            )
            await delay_sing_messages((reply,), CLEAN_REMOVER)
            return
        m_audio = m
    elif m.reply_to_message and m.reply_to_message.audio:
        m_audio = m.reply_to_message
        if m_audio.audio.duration > (MAX_HOUR * 60 * 60):
            reply = await m.reply_text(
                f"{emoji.ROBOT} audio which duration longer than "
                f"{str(MAX_HOUR)} hours won't be added to playlist"
            )
            await delay_sing_messages((reply,), CLEAN_REMOVER)
            return
    else:
        await xep.send_playlist()
        await m.delete()
        return
    # check already added
    if playlist and playlist[-1].audio.file_unique_id \
            == m_audio.audio.file_unique_id:
        reply = await m.reply_text(f"{emoji.ROBOT} already added")
        await delay_sing_messages((reply, m), CLEAN_REMOVER)
        return
    # add to playlist
    playlist.append(m_audio)
    if len(playlist) == 1:
        m_status = await m.reply_text(
            f"{emoji.INBOX_TRAY} downloading and transcoding..."
        )
        await download_audio(playlist[0])
        group_call.input_filename = os.path.join(
            client.workdir,
            DEFAULT_DOWNLOAD_DIR,
            f"{playlist[0].audio.file_unique_id}.raw"
        )
        await xep.update_start_time()
        await m_status.delete()
        print(f"- START PLAYING: {playlist[0].audio.title}")
    await xep.send_playlist()
    for track in playlist[:2]:
        await download_audio(track)
    if not m.audio:
        await m.delete()